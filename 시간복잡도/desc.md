### TIP

- 10^18 이상 : 어느 순간부터 규칙이 나타날 수 있다.    

- 시간복잡도 즐이는 솔루션
1. Depth 줄이기    
삼중 for 문 -> 이중 for 문 + 배열로 check
2. 입력값 줄이기 -> while 문 등을 활용하여 가능한 경우의 수만 딱 떨어지게 돌아가도록 설정하기
3. 중복될 수 있는지 확인하기 -> bfs / union-find 등의 알고리즘을 사용할 때 중복되는 부분 배제시키기


### 시간복잡도
- n개의 List와 m개의 List를 합병 분할한다면 O(M+N-1)번의 비교 횟수를 가진다. 


### 입출력으로 유형 생각해보기 (유력한 알고리즘 유형 규칙 - 주로 이랬다)
**1<= N <= 10,15,20**
- 백트래킹   

**1<= N <= 7 -> 어떤 n, m 조합이라도 문제를 시간 내에 풀 수 있음**
- 구현, 시뮬 / 브루트포스 / 수학 / 백트래킹 (nCm도 가능하도록 함)  

**1<= N <= 10^9**
- 단일 이분탐색 
- O(logN) 의 시간복잡도 적합

**1<= N <= 10^5**
- 이분탐색, 정렬
- O(NlogN) 의 시간복잡도 적합

**1<= N <=10^7**
- 투포인터 유리
- O(N) 의 시간복잡도가 적합
- 수학 문제 가능 / 정렬 위험

### 아이디어성
**DP vs 그리디**
- 의존성

**그래프**
- 다익스트라, DFS, BFS

**자료구조**
- 조회 시에는 List보다 O(1)인 dictionary가 더 유리할 수 있다.
- stack : 100만도 가능 O(N)
